{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { gsap } from \"gsap\";\n// 现在浏览器支持ES6语法，自然包括import方式引入js文件\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/addons/loaders/GLTFLoader.js\";\nimport { FontLoader } from \"three/addons/loaders/FontLoader.js\";\nimport { TextGeometry } from \"three/examples/jsm/geometries/TextGeometry.js\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport Stats from \"three/examples/jsm/libs/stats.module.js\";\nimport * as d3 from \"d3\";\nimport axios from \"network/axios\";\nexport default {\n  data() {\n    return {\n      renderer: null,\n      scene: null,\n      camera: null,\n      controls: null,\n      v: null,\n      material: null,\n      particleMaterial: null,\n      firefliesMaterial: null,\n      textMaterial: null,\n      clock: null,\n      //外层圆圈\n      particles: null,\n      stats: null\n    };\n  },\n  created() {},\n  mounted() {\n    this.stats = new Stats();\n    this.clock = new THREE.Clock();\n    document.body.appendChild(this.stats.domElement);\n    this.start();\n  },\n  destroyed() {\n    // this.clearScene();\n    // this.destroyThreejs();\n    console.log(\"执行destroyed钩子函数\");\n  },\n  methods: {\n    templateshader() {\n      const vertex = ``;\n      const fragment = ``;\n      this.material = new THREE.ShaderMaterial({\n        uniforms: {\n          uTime: {\n            value: 0\n          }\n        },\n        vertexShader: vertex,\n        fragmentShader: fragment\n        // wireframe: true,\n        // wireframe: true,\n      });\n      const geometry = new THREE.SphereGeometry(1, 128, 128);\n      const mesh = new THREE.Mesh(geometry, this.material);\n      this.scene.add(mesh);\n    },\n    //黄色毛球\n    shader1() {\n      const vertex = `vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n      float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\n      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n      float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n      vec4 grad4(float j, vec4 ip){\n        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n        vec4 p,s;\n\n        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n        s = vec4(lessThan(p, vec4(0.0)));\n        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n        return p;\n      }\n\n      float snoise(vec4 v){\n        const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                              0.309016994374947451); // (sqrt(5) - 1)/4   F4\n      // First corner\n        vec4 i  = floor(v + dot(v, C.yyyy) );\n        vec4 x0 = v -   i + dot(i, C.xxxx);\n\n      // Other corners\n\n      // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n        vec4 i0;\n\n        vec3 isX = step( x0.yzw, x0.xxx );\n        vec3 isYZ = step( x0.zww, x0.yyz );\n      //  i0.x = dot( isX, vec3( 1.0 ) );\n        i0.x = isX.x + isX.y + isX.z;\n        i0.yzw = 1.0 - isX;\n\n      //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n        i0.y += isYZ.x + isYZ.y;\n        i0.zw += 1.0 - isYZ.xy;\n\n        i0.z += isYZ.z;\n        i0.w += 1.0 - isYZ.z;\n\n        // i0 now contains the unique values 0,1,2,3 in each channel\n        vec4 i3 = clamp( i0, 0.0, 1.0 );\n        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n        //  x0 = x0 - 0.0 + 0.0 * C\n        vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n        vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n        vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n        vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n      // Permutations\n        i = mod(i, 289.0);\n        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n        vec4 j1 = permute( permute( permute( permute (\n                   i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                 + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                 + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                 + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n      // Gradients\n      // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n      // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n        vec4 p0 = grad4(j0,   ip);\n        vec4 p1 = grad4(j1.x, ip);\n        vec4 p2 = grad4(j1.y, ip);\n        vec4 p3 = grad4(j1.z, ip);\n        vec4 p4 = grad4(j1.w, ip);\n\n      // Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        p4 *= taylorInvSqrt(dot(p4,p4));\n\n      // Mix contributions from the five corners\n        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n        m0 = m0 * m0;\n        m1 = m1 * m1;\n        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                     + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n      }\n\n\n      varying vec3 vNormal;\n      varying float vNoise;\n      varying vec2 vUv;\n      uniform float uTime;\n      void main() {\n        vec3 newPos = position;\n        float noise = snoise(vec4(position * 10.0, uTime));\n        newPos += normal * noise *1.0;\n        vNoise = noise;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\n      }`;\n      const fragment = `float hue2rgb(float f1, float f2, float hue) {\n          if (hue < 0.0)\n              hue += 1.0;\n          else if (hue > 1.0)\n              hue -= 1.0;\n          float res;\n          if ((6.0 * hue) < 1.0)\n              res = f1 + (f2 - f1) * 6.0 * hue;\n          else if ((2.0 * hue) < 1.0)\n              res = f2;\n          else if ((3.0 * hue) < 2.0)\n              res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n          else\n              res = f1;\n          return res;\n      }\n\n      vec3 hsl2rgb(vec3 hsl) {\n          vec3 rgb;\n\n          if (hsl.y == 0.0) {\n              rgb = vec3(hsl.z); // Luminance\n          } else {\n              float f2;\n\n              if (hsl.z < 0.5)\n                  f2 = hsl.z * (1.0 + hsl.y);\n              else\n                  f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n\n              float f1 = 2.0 * hsl.z - f2;\n\n              rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n              rgb.g = hue2rgb(f1, f2, hsl.x);\n              rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n          }\n          return rgb;\n      }\n\n      vec3 hsl2rgb(float h, float s, float l) {\n          return hsl2rgb(vec3(h, s, l));\n      }\n\n            vec3 rgb(float r, float g, float b) {\n        return vec3(r, g, b) / 255.;\n      }\n            varying vec2 vUv;\n            uniform float uTime;\n            varying vec3 vNormal;\n            varying float vNoise;\n            void main() {\n              vec3 color = hsl2rgb(0.1 + vNoise * 0.1, 1.0, 0.5);\n        gl_FragColor = vec4(color, 1.0);\n      }`;\n      this.material = new THREE.ShaderMaterial({\n        uniforms: {\n          uTime: {\n            value: 0\n          }\n        },\n        vertexShader: vertex,\n        fragmentShader: fragment\n        // wireframe: true,\n        // wireframe: true,\n      });\n      const geometry = new THREE.SphereGeometry(1, 128, 128);\n      const mesh = new THREE.Mesh(geometry, this.material);\n      this.scene.add(mesh);\n    },\n    //外围圆圈\n    shader2() {\n      const vertex = `  uniform float uTime;\n  varying vec3 vColor;\n  const float PI = 3.141592653589793238;\n  void main() {\n    vec3 newPos = position;\n   newPos.y += 0.1 * sin(newPos.y * 3.0 + uTime*5.0);\n  newPos.z += 0.05 * sin(newPos.y * 3.0 + uTime*5.0);\n  vColor=newPos;\n    vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\n    gl_PointSize = 20.0 / -mvPosition.z;\n    gl_Position = projectionMatrix * mvPosition;\n  }`;\n      const fragment = `      uniform float uTime;\n      varying vec3 vColor;\n  void main() {\n    float d = length(gl_PointCoord - 0.5);\n  if (d > 0.5) discard;\n    // gl_FragColor = vec4(vec3(1.0), 1.0);\n    gl_FragColor = vec4(vColor, 1.0);\n  }`;\n      this.particleMaterial = new THREE.ShaderMaterial({\n        uniforms: {\n          uTime: {\n            value: 0\n          }\n        },\n        vertexShader: vertex,\n        fragmentShader: fragment,\n        transparent: true,\n        blending: THREE.AdditiveBlending\n        // wireframe: true,\n        // wireframe: true,\n      });\n      const particleGeometry = new THREE.BufferGeometry();\n      const N = 4000;\n      const positions = new Float32Array(N * 3);\n      const inc = Math.PI * (3 - Math.sqrt(5));\n      const off = 2 / N;\n      //   for (let i = 0; i < N; i++) {\n      //     const y = i * off - 1 + off / 2;\n      //     const r = Math.sqrt(1 - y * y);\n      //     const phi = i * inc;\n\n      //     positions[3 * i] = radius * Math.cos(phi) * r;\n      //     positions[3 * i + 1] = radius * y;\n      //     positions[3 * i + 2] = radius * Math.sin(phi) * r;\n      //   }\n      const radius = 2.2;\n      for (let i = 0; i < N; i++) {\n        const k = i + 0.5;\n        const phi = Math.acos(1 - 2 * k / N);\n        const theta = Math.PI * (1 + Math.sqrt(5)) * k;\n        const x = Math.cos(theta) * Math.sin(phi) * radius;\n        const y = Math.sin(theta) * Math.sin(phi) * radius;\n        const z = Math.cos(phi) * radius;\n        positions.set([x, y, z], i * 3);\n      }\n      particleGeometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n      this.particles = new THREE.Points(particleGeometry, this.particleMaterial);\n      this.scene.add(this.particles);\n    },\n    //浮动字体\n    shader3() {\n      const vertex = `  uniform float uTime;\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    // newPos.y += 0.06 * sin(newPos.x + uTime);\n    // newPos.x += 0.1 * sin(newPos.x * 2.0 + uTime);\n    newPos.y += 0.1 * sin(newPos.y * 3.0 + uTime*5.0);\n  newPos.z += 0.05 * sin(newPos.y * 3.0 + uTime*5.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\n  }`;\n      const fragment = `  uniform sampler2D uTexture;\n  varying vec2 vUv;\n\n  void main() {\n    vec4 color = texture2D(uTexture, vUv);\n    gl_FragColor = color;\n  }`;\n      this.textMaterial = new THREE.ShaderMaterial({\n        uniforms: {\n          uTime: {\n            value: 0\n          },\n          uTexture: {\n            value: new THREE.TextureLoader().load(require(\"@/assets/images/ouyang2.png\"))\n          }\n        },\n        transparent: true,\n        vertexShader: vertex,\n        fragmentShader: fragment\n        // wireframe: true,\n        // wireframe: true,\n      });\n      const textGeometry = new THREE.PlaneGeometry(2, 1, 100, 100);\n      const text = new THREE.Mesh(textGeometry, this.textMaterial);\n      text.position.z = 2;\n      this.scene.add(text);\n    },\n    //环境粒子\n    shader4() {\n      const vertex = `uniform float uTime;\n    attribute float aSize;\n      \n    void main() {\n        vec3 newPos = position;\n        newPos.y += sin(uTime * 0.5 + newPos.x * 100.0) * aSize * 0.2;\n        newPos.x += sin(uTime * 0.5 + newPos.x * 200.0) * aSize * 0.1;\n        \n        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\n        gl_PointSize = 70.0 * aSize / -mvPosition.z;\n        gl_Position = projectionMatrix * mvPosition;\n    }`;\n      const fragment = `void main() {\n      float d = length(gl_PointCoord - vec2(0.5));\n      float strength = clamp(0.05 / d - 0.05 * 2.0, 0.0, 1.0);\n      gl_FragColor = vec4(vec3(1.0), strength);\n  }`;\n      this.firefliesMaterial = new THREE.ShaderMaterial({\n        uniforms: {\n          uTime: {\n            value: 0\n          }\n        },\n        vertexShader: vertex,\n        fragmentShader: fragment,\n        transparent: true,\n        blending: THREE.AdditiveBlending,\n        depthWrite: false\n        // wireframe: true,\n        // wireframe: true,\n      });\n      const firefliesGeometry = new THREE.BufferGeometry();\n      const firefliesCount = 300;\n      const positions1 = new Float32Array(firefliesCount * 3);\n      const sizes = new Float32Array(firefliesCount);\n      for (let i = 0; i < firefliesCount; i++) {\n        const r = Math.random() * 5 + 5;\n        positions1[i * 3 + 0] = (Math.random() - 0.5) * r;\n        positions1[i * 3 + 1] = (Math.random() - 0.5) * r;\n        positions1[i * 3 + 2] = (Math.random() - 0.5) * r;\n        sizes[i] = Math.random() + 1.0;\n      }\n      firefliesGeometry.setAttribute(\"position\", new THREE.BufferAttribute(positions1, 3));\n      firefliesGeometry.setAttribute(\"aSize\", new THREE.BufferAttribute(sizes, 1));\n      const fireflies = new THREE.Points(firefliesGeometry, this.firefliesMaterial);\n      this.scene.add(fireflies);\n    },\n    clearScene() {\n      cancelAnimationFrame(this.render);\n      this.scene.traverse(child => {\n        if (child.material) {\n          child.material.dispose();\n        }\n        if (child.geometry) {\n          child.geometry.dispose();\n        }\n        child = null;\n      });\n      // this.sceneDomElement.innerHTML = \"\";\n      this.renderer.dispose();\n      this.renderer.forceContextLoss();\n      this.renderer.clear();\n      this.scene.clear();\n      console.log(\"clearScene\");\n    },\n    destroyThreejs() {\n      try {\n        this.renderer.dispose();\n        this.renderer.forceContextLoss();\n        this.renderer.content = null;\n        let gl = this.renderer.domElement.getContext(\"webgl\");\n        if (gl && gl.getExtension(\"WEBGL_lose_context\")) {\n          gl.getExtension(\"WEBGL_lose_context\").loseContext();\n        }\n        this.renderer = null;\n        this.camera = null;\n        this.scene.traverse(child => {\n          if (child.material) {\n            child.material.dispose();\n          }\n          if (child.geometry) {\n            child.geometry.dispose();\n          }\n          child = null;\n        });\n        this.scene = null;\n      } catch (e) {\n        console.error(\"Failed to destroy threejs\", e);\n      }\n    },\n    // 初始化场景\n    initScene() {\n      this.scene = new THREE.Scene();\n      //给场景添加烟雾效果\n      // 参数：烟雾颜色，烟雾范围near，烟雾范围far\n      this.scene.background = new THREE.Color(0x000000);\n      // this.scene.background = new THREE.Color(0xffffff);\n      this.scene.fog = new THREE.Fog(0xffffff, 0, 3000);\n      // 给场景添加坐标轴\n      // var axes = new THREE.AxesHelper(100);\n      // this.scene.add(axes);\n    },\n    // 初始化渲染器\n    initRenderer() {\n      // antialias是否开启抗锯齿\n      const canvas = document.querySelector(\"#three\");\n      this.renderer = new THREE.WebGLRenderer({\n        canvas,\n        antialias: true,\n        alpha: true\n      });\n      this.renderer.setClearAlpha(0.2);\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n      this.renderer.physicallyCorrectLights = true;\n    },\n    // 初始化相机\n    initCamera() {\n      this.v = new THREE.Vector3(32.499207496643066, 38.21255111694336, 0);\n      this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n      this.camera.position.set(0, 0, 8);\n      this.camera.lookAt(this.v);\n    },\n    // 初始化控制器\n    initControls() {\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      // 阻尼效果\n      this.controls.enableDamping = true;\n      // 摄像机自动旋转\n      this.controls.autoRotate = false;\n      // 控制垂直角度的旋转范围\n      // controls;\n    },\n    //初始化光源\n    initLight() {\n      const directionalLight = new THREE.DirectionalLight(0xe8eaeb, 0.2);\n      directionalLight.position.set(0, 10, 5);\n      this.scene.add(directionalLight);\n    },\n    render() {\n      // 触底弹跳\n      const time = this.clock.getElapsedTime();\n      this.material.uniforms.uTime.value = time;\n      this.particleMaterial.uniforms.uTime.value = time;\n      this.firefliesMaterial.uniforms.uTime.value = time;\n      this.textMaterial.uniforms.uTime.value = time;\n      this.particles.rotation.y = time;\n      // mesh.rotation.y = time;\n      requestAnimationFrame(this.render);\n      this.renderer.render(this.scene, this.camera);\n      this.controls.update();\n      this.stats.update(); //更新性能插件\n    },\n    ownFun() {\n      this.shader1();\n      this.shader2();\n      this.shader3();\n      this.shader4();\n    },\n    start() {\n      this.initRenderer();\n      this.initScene();\n      this.initCamera();\n      this.initControls();\n      this.initLight();\n      this.ownFun();\n      this.render();\n    }\n  }\n};","map":{"version":3,"names":["gsap","THREE","GLTFLoader","FontLoader","TextGeometry","OrbitControls","Stats","d3","axios","data","renderer","scene","camera","controls","v","material","particleMaterial","firefliesMaterial","textMaterial","clock","particles","stats","created","mounted","Clock","document","body","appendChild","domElement","start","destroyed","console","log","methods","templateshader","vertex","fragment","ShaderMaterial","uniforms","uTime","value","vertexShader","fragmentShader","geometry","SphereGeometry","mesh","Mesh","add","shader1","shader2","transparent","blending","AdditiveBlending","particleGeometry","BufferGeometry","N","positions","Float32Array","inc","Math","PI","sqrt","off","radius","i","k","phi","acos","theta","x","cos","sin","y","z","set","setAttribute","BufferAttribute","Points","shader3","uTexture","TextureLoader","load","require","textGeometry","PlaneGeometry","text","position","shader4","depthWrite","firefliesGeometry","firefliesCount","positions1","sizes","r","random","fireflies","clearScene","cancelAnimationFrame","render","traverse","child","dispose","forceContextLoss","clear","destroyThreejs","content","gl","getContext","getExtension","loseContext","e","error","initScene","Scene","background","Color","fog","Fog","initRenderer","canvas","querySelector","WebGLRenderer","antialias","alpha","setClearAlpha","setSize","window","innerWidth","innerHeight","physicallyCorrectLights","initCamera","Vector3","PerspectiveCamera","lookAt","initControls","enableDamping","autoRotate","initLight","directionalLight","DirectionalLight","time","getElapsedTime","rotation","requestAnimationFrame","update","ownFun"],"sources":["src/views/three1/index.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <canvas id=\"three\"></canvas>\r\n  </div>\r\n</template>\r\n  \r\n  <script>\r\nimport { gsap } from \"gsap\";\r\n// 现在浏览器支持ES6语法，自然包括import方式引入js文件\r\nimport * as THREE from \"three\";\r\nimport { GLTFLoader } from \"three/addons/loaders/GLTFLoader.js\";\r\nimport { FontLoader } from \"three/addons/loaders/FontLoader.js\";\r\nimport { TextGeometry } from \"three/examples/jsm/geometries/TextGeometry.js\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\nimport Stats from \"three/examples/jsm/libs/stats.module.js\";\r\nimport * as d3 from \"d3\";\r\nimport axios from \"network/axios\";\r\nexport default {\r\n  data() {\r\n    return {\r\n      renderer: null,\r\n      scene: null,\r\n      camera: null,\r\n      controls: null,\r\n      v: null,\r\n      material: null,\r\n      particleMaterial: null,\r\n      firefliesMaterial: null,\r\n      textMaterial: null,\r\n      clock: null,\r\n      //外层圆圈\r\n      particles: null,\r\n      stats: null,\r\n    };\r\n  },\r\n  created() {},\r\n  mounted() {\r\n    this.stats = new Stats();\r\n    this.clock = new THREE.Clock();\r\n    document.body.appendChild(this.stats.domElement);\r\n    this.start();\r\n  },\r\n  destroyed() {\r\n    // this.clearScene();\r\n    // this.destroyThreejs();\r\n    console.log(\"执行destroyed钩子函数\");\r\n  },\r\n  methods: {\r\n    templateshader() {\r\n      const vertex = ``;\r\n      const fragment = ``;\r\n      this.material = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          uTime: { value: 0 },\r\n        },\r\n        vertexShader: vertex,\r\n        fragmentShader: fragment,\r\n        // wireframe: true,\r\n        // wireframe: true,\r\n      });\r\n      const geometry = new THREE.SphereGeometry(1, 128, 128);\r\n      const mesh = new THREE.Mesh(geometry, this.material);\r\n      this.scene.add(mesh);\r\n    },\r\n    //黄色毛球\r\n    shader1() {\r\n      const vertex = `vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\r\n      float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\r\n      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\r\n      float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\r\n\r\n      vec4 grad4(float j, vec4 ip){\r\n        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\r\n        vec4 p,s;\r\n\r\n        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\r\n        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\r\n        s = vec4(lessThan(p, vec4(0.0)));\r\n        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\r\n\r\n        return p;\r\n      }\r\n\r\n      float snoise(vec4 v){\r\n        const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\r\n                              0.309016994374947451); // (sqrt(5) - 1)/4   F4\r\n      // First corner\r\n        vec4 i  = floor(v + dot(v, C.yyyy) );\r\n        vec4 x0 = v -   i + dot(i, C.xxxx);\r\n\r\n      // Other corners\r\n\r\n      // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\r\n        vec4 i0;\r\n\r\n        vec3 isX = step( x0.yzw, x0.xxx );\r\n        vec3 isYZ = step( x0.zww, x0.yyz );\r\n      //  i0.x = dot( isX, vec3( 1.0 ) );\r\n        i0.x = isX.x + isX.y + isX.z;\r\n        i0.yzw = 1.0 - isX;\r\n\r\n      //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\r\n        i0.y += isYZ.x + isYZ.y;\r\n        i0.zw += 1.0 - isYZ.xy;\r\n\r\n        i0.z += isYZ.z;\r\n        i0.w += 1.0 - isYZ.z;\r\n\r\n        // i0 now contains the unique values 0,1,2,3 in each channel\r\n        vec4 i3 = clamp( i0, 0.0, 1.0 );\r\n        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\r\n        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\r\n\r\n        //  x0 = x0 - 0.0 + 0.0 * C\r\n        vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\r\n        vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\r\n        vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\r\n        vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\r\n\r\n      // Permutations\r\n        i = mod(i, 289.0);\r\n        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\r\n        vec4 j1 = permute( permute( permute( permute (\r\n                   i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\r\n                 + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\r\n                 + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\r\n                 + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\r\n      // Gradients\r\n      // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\r\n      // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\r\n\r\n        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\r\n\r\n        vec4 p0 = grad4(j0,   ip);\r\n        vec4 p1 = grad4(j1.x, ip);\r\n        vec4 p2 = grad4(j1.y, ip);\r\n        vec4 p3 = grad4(j1.z, ip);\r\n        vec4 p4 = grad4(j1.w, ip);\r\n\r\n      // Normalise gradients\r\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n        p0 *= norm.x;\r\n        p1 *= norm.y;\r\n        p2 *= norm.z;\r\n        p3 *= norm.w;\r\n        p4 *= taylorInvSqrt(dot(p4,p4));\r\n\r\n      // Mix contributions from the five corners\r\n        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\r\n        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\r\n        m0 = m0 * m0;\r\n        m1 = m1 * m1;\r\n        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\r\n                     + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\r\n      }\r\n\r\n\r\n      varying vec3 vNormal;\r\n      varying float vNoise;\r\n      varying vec2 vUv;\r\n      uniform float uTime;\r\n      void main() {\r\n        vec3 newPos = position;\r\n        float noise = snoise(vec4(position * 10.0, uTime));\r\n        newPos += normal * noise *1.0;\r\n        vNoise = noise;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\r\n      }`;\r\n      const fragment = `float hue2rgb(float f1, float f2, float hue) {\r\n          if (hue < 0.0)\r\n              hue += 1.0;\r\n          else if (hue > 1.0)\r\n              hue -= 1.0;\r\n          float res;\r\n          if ((6.0 * hue) < 1.0)\r\n              res = f1 + (f2 - f1) * 6.0 * hue;\r\n          else if ((2.0 * hue) < 1.0)\r\n              res = f2;\r\n          else if ((3.0 * hue) < 2.0)\r\n              res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n          else\r\n              res = f1;\r\n          return res;\r\n      }\r\n\r\n      vec3 hsl2rgb(vec3 hsl) {\r\n          vec3 rgb;\r\n\r\n          if (hsl.y == 0.0) {\r\n              rgb = vec3(hsl.z); // Luminance\r\n          } else {\r\n              float f2;\r\n\r\n              if (hsl.z < 0.5)\r\n                  f2 = hsl.z * (1.0 + hsl.y);\r\n              else\r\n                  f2 = hsl.z + hsl.y - hsl.y * hsl.z;\r\n\r\n              float f1 = 2.0 * hsl.z - f2;\r\n\r\n              rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\r\n              rgb.g = hue2rgb(f1, f2, hsl.x);\r\n              rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\r\n          }\r\n          return rgb;\r\n      }\r\n\r\n      vec3 hsl2rgb(float h, float s, float l) {\r\n          return hsl2rgb(vec3(h, s, l));\r\n      }\r\n\r\n            vec3 rgb(float r, float g, float b) {\r\n        return vec3(r, g, b) / 255.;\r\n      }\r\n            varying vec2 vUv;\r\n            uniform float uTime;\r\n            varying vec3 vNormal;\r\n            varying float vNoise;\r\n            void main() {\r\n              vec3 color = hsl2rgb(0.1 + vNoise * 0.1, 1.0, 0.5);\r\n        gl_FragColor = vec4(color, 1.0);\r\n      }`;\r\n      this.material = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          uTime: { value: 0 },\r\n        },\r\n        vertexShader: vertex,\r\n        fragmentShader: fragment,\r\n        // wireframe: true,\r\n        // wireframe: true,\r\n      });\r\n      const geometry = new THREE.SphereGeometry(1, 128, 128);\r\n      const mesh = new THREE.Mesh(geometry, this.material);\r\n      this.scene.add(mesh);\r\n    },\r\n    //外围圆圈\r\n    shader2() {\r\n      const vertex = `  uniform float uTime;\r\n  varying vec3 vColor;\r\n  const float PI = 3.141592653589793238;\r\n  void main() {\r\n    vec3 newPos = position;\r\n   newPos.y += 0.1 * sin(newPos.y * 3.0 + uTime*5.0);\r\n  newPos.z += 0.05 * sin(newPos.y * 3.0 + uTime*5.0);\r\n  vColor=newPos;\r\n    vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\r\n    gl_PointSize = 20.0 / -mvPosition.z;\r\n    gl_Position = projectionMatrix * mvPosition;\r\n  }`;\r\n      const fragment = `      uniform float uTime;\r\n      varying vec3 vColor;\r\n  void main() {\r\n    float d = length(gl_PointCoord - 0.5);\r\n  if (d > 0.5) discard;\r\n    // gl_FragColor = vec4(vec3(1.0), 1.0);\r\n    gl_FragColor = vec4(vColor, 1.0);\r\n  }`;\r\n      this.particleMaterial = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          uTime: { value: 0 },\r\n        },\r\n        vertexShader: vertex,\r\n        fragmentShader: fragment,\r\n        transparent: true,\r\n        blending: THREE.AdditiveBlending,\r\n        // wireframe: true,\r\n        // wireframe: true,\r\n      });\r\n\r\n      const particleGeometry = new THREE.BufferGeometry();\r\n      const N = 4000;\r\n      const positions = new Float32Array(N * 3);\r\n\r\n      const inc = Math.PI * (3 - Math.sqrt(5));\r\n      const off = 2 / N;\r\n      //   for (let i = 0; i < N; i++) {\r\n      //     const y = i * off - 1 + off / 2;\r\n      //     const r = Math.sqrt(1 - y * y);\r\n      //     const phi = i * inc;\r\n\r\n      //     positions[3 * i] = radius * Math.cos(phi) * r;\r\n      //     positions[3 * i + 1] = radius * y;\r\n      //     positions[3 * i + 2] = radius * Math.sin(phi) * r;\r\n      //   }\r\n      const radius = 2.2;\r\n      for (let i = 0; i < N; i++) {\r\n        const k = i + 0.5;\r\n        const phi = Math.acos(1 - (2 * k) / N);\r\n        const theta = Math.PI * (1 + Math.sqrt(5)) * k;\r\n        const x = Math.cos(theta) * Math.sin(phi) * radius;\r\n        const y = Math.sin(theta) * Math.sin(phi) * radius;\r\n        const z = Math.cos(phi) * radius;\r\n\r\n        positions.set([x, y, z], i * 3);\r\n      }\r\n      particleGeometry.setAttribute(\r\n        \"position\",\r\n        new THREE.BufferAttribute(positions, 3)\r\n      );\r\n      this.particles = new THREE.Points(\r\n        particleGeometry,\r\n        this.particleMaterial\r\n      );\r\n      this.scene.add(this.particles);\r\n    },\r\n    //浮动字体\r\n    shader3() {\r\n      const vertex = `  uniform float uTime;\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n    vUv = uv;\r\n\r\n    vec3 newPos = position;\r\n    // newPos.y += 0.06 * sin(newPos.x + uTime);\r\n    // newPos.x += 0.1 * sin(newPos.x * 2.0 + uTime);\r\n    newPos.y += 0.1 * sin(newPos.y * 3.0 + uTime*5.0);\r\n  newPos.z += 0.05 * sin(newPos.y * 3.0 + uTime*5.0);\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\r\n  }`;\r\n      const fragment = `  uniform sampler2D uTexture;\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n    vec4 color = texture2D(uTexture, vUv);\r\n    gl_FragColor = color;\r\n  }`;\r\n      this.textMaterial = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          uTime: { value: 0 },\r\n          uTexture: {\r\n            value: new THREE.TextureLoader().load(\r\n              require(\"@/assets/images/ouyang2.png\")\r\n            ),\r\n          },\r\n        },\r\n        transparent: true,\r\n        vertexShader: vertex,\r\n        fragmentShader: fragment,\r\n        // wireframe: true,\r\n        // wireframe: true,\r\n      });\r\n\r\n      const textGeometry = new THREE.PlaneGeometry(2, 1, 100, 100);\r\n      const text = new THREE.Mesh(textGeometry, this.textMaterial);\r\n      text.position.z = 2;\r\n      this.scene.add(text);\r\n    },\r\n    //环境粒子\r\n    shader4() {\r\n      const vertex = `uniform float uTime;\r\n    attribute float aSize;\r\n      \r\n    void main() {\r\n        vec3 newPos = position;\r\n        newPos.y += sin(uTime * 0.5 + newPos.x * 100.0) * aSize * 0.2;\r\n        newPos.x += sin(uTime * 0.5 + newPos.x * 200.0) * aSize * 0.1;\r\n        \r\n        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);\r\n        gl_PointSize = 70.0 * aSize / -mvPosition.z;\r\n        gl_Position = projectionMatrix * mvPosition;\r\n    }`;\r\n      const fragment = `void main() {\r\n      float d = length(gl_PointCoord - vec2(0.5));\r\n      float strength = clamp(0.05 / d - 0.05 * 2.0, 0.0, 1.0);\r\n      gl_FragColor = vec4(vec3(1.0), strength);\r\n  }`;\r\n      this.firefliesMaterial = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          uTime: { value: 0 },\r\n        },\r\n        vertexShader: vertex,\r\n        fragmentShader: fragment,\r\n        transparent: true,\r\n        blending: THREE.AdditiveBlending,\r\n        depthWrite: false,\r\n        // wireframe: true,\r\n        // wireframe: true,\r\n      });\r\n\r\n      const firefliesGeometry = new THREE.BufferGeometry();\r\n      const firefliesCount = 300;\r\n      const positions1 = new Float32Array(firefliesCount * 3);\r\n      const sizes = new Float32Array(firefliesCount);\r\n\r\n      for (let i = 0; i < firefliesCount; i++) {\r\n        const r = Math.random() * 5 + 5;\r\n        positions1[i * 3 + 0] = (Math.random() - 0.5) * r;\r\n        positions1[i * 3 + 1] = (Math.random() - 0.5) * r;\r\n        positions1[i * 3 + 2] = (Math.random() - 0.5) * r;\r\n\r\n        sizes[i] = Math.random() + 1.0;\r\n      }\r\n\r\n      firefliesGeometry.setAttribute(\r\n        \"position\",\r\n        new THREE.BufferAttribute(positions1, 3)\r\n      );\r\n      firefliesGeometry.setAttribute(\r\n        \"aSize\",\r\n        new THREE.BufferAttribute(sizes, 1)\r\n      );\r\n\r\n      const fireflies = new THREE.Points(\r\n        firefliesGeometry,\r\n        this.firefliesMaterial\r\n      );\r\n      this.scene.add(fireflies);\r\n    },\r\n    clearScene() {\r\n      cancelAnimationFrame(this.render);\r\n      this.scene.traverse((child) => {\r\n        if (child.material) {\r\n          child.material.dispose();\r\n        }\r\n        if (child.geometry) {\r\n          child.geometry.dispose();\r\n        }\r\n        child = null;\r\n      });\r\n      // this.sceneDomElement.innerHTML = \"\";\r\n      this.renderer.dispose();\r\n      this.renderer.forceContextLoss();\r\n      this.renderer.clear();\r\n      this.scene.clear();\r\n      console.log(\"clearScene\");\r\n    },\r\n    destroyThreejs() {\r\n      try {\r\n        this.renderer.dispose();\r\n        this.renderer.forceContextLoss();\r\n        this.renderer.content = null;\r\n        let gl = this.renderer.domElement.getContext(\"webgl\");\r\n        if (gl && gl.getExtension(\"WEBGL_lose_context\")) {\r\n          gl.getExtension(\"WEBGL_lose_context\").loseContext();\r\n        }\r\n        this.renderer = null;\r\n        this.camera = null;\r\n        this.scene.traverse((child) => {\r\n          if (child.material) {\r\n            child.material.dispose();\r\n          }\r\n          if (child.geometry) {\r\n            child.geometry.dispose();\r\n          }\r\n          child = null;\r\n        });\r\n        this.scene = null;\r\n      } catch (e) {\r\n        console.error(\"Failed to destroy threejs\", e);\r\n      }\r\n    },\r\n    // 初始化场景\r\n    initScene() {\r\n      this.scene = new THREE.Scene();\r\n      //给场景添加烟雾效果\r\n      // 参数：烟雾颜色，烟雾范围near，烟雾范围far\r\n      this.scene.background = new THREE.Color(0x000000);\r\n      // this.scene.background = new THREE.Color(0xffffff);\r\n      this.scene.fog = new THREE.Fog(0xffffff, 0, 3000);\r\n      // 给场景添加坐标轴\r\n      // var axes = new THREE.AxesHelper(100);\r\n      // this.scene.add(axes);\r\n    },\r\n    // 初始化渲染器\r\n    initRenderer() {\r\n      // antialias是否开启抗锯齿\r\n      const canvas = document.querySelector(\"#three\");\r\n      this.renderer = new THREE.WebGLRenderer({\r\n        canvas,\r\n        antialias: true,\r\n        alpha: true,\r\n      });\r\n      this.renderer.setClearAlpha(0.2);\r\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n      this.renderer.physicallyCorrectLights = true;\r\n    },\r\n    // 初始化相机\r\n    initCamera() {\r\n      this.v = new THREE.Vector3(32.499207496643066, 38.21255111694336, 0);\r\n      this.camera = new THREE.PerspectiveCamera(\r\n        45,\r\n        window.innerWidth / window.innerHeight,\r\n        0.1,\r\n        1000\r\n      );\r\n      this.camera.position.set(0, 0, 8);\r\n      this.camera.lookAt(this.v);\r\n    }, // 初始化控制器\r\n    initControls() {\r\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\r\n      // 阻尼效果\r\n      this.controls.enableDamping = true;\r\n      // 摄像机自动旋转\r\n      this.controls.autoRotate = false;\r\n      // 控制垂直角度的旋转范围\r\n      // controls;\r\n    },\r\n    //初始化光源\r\n    initLight() {\r\n      const directionalLight = new THREE.DirectionalLight(0xe8eaeb, 0.2);\r\n      directionalLight.position.set(0, 10, 5);\r\n      this.scene.add(directionalLight);\r\n    },\r\n    render() {\r\n      // 触底弹跳\r\n      const time = this.clock.getElapsedTime();\r\n      this.material.uniforms.uTime.value = time;\r\n      this.particleMaterial.uniforms.uTime.value = time;\r\n      this.firefliesMaterial.uniforms.uTime.value = time;\r\n      this.textMaterial.uniforms.uTime.value = time;\r\n      this.particles.rotation.y = time;\r\n      // mesh.rotation.y = time;\r\n      requestAnimationFrame(this.render);\r\n      this.renderer.render(this.scene, this.camera);\r\n      this.controls.update();\r\n      this.stats.update(); //更新性能插件\r\n    },\r\n    ownFun() {\r\n      this.shader1();\r\n      this.shader2();\r\n      this.shader3();\r\n      this.shader4();\r\n    },\r\n    start() {\r\n      this.initRenderer();\r\n      this.initScene();\r\n      this.initCamera();\r\n      this.initControls();\r\n      this.initLight();\r\n      this.ownFun();\r\n      this.render();\r\n    },\r\n  },\r\n};\r\n</script>\r\n  <style src=\"@/assets/style/three.css\"  scoped></style>"],"mappings":";;;;;;AAOA,SAAAA,IAAA;AACA;AACA,YAAAC,KAAA;AACA,SAAAC,UAAA;AACA,SAAAC,UAAA;AACA,SAAAC,YAAA;AACA,SAAAC,aAAA;AACA,OAAAC,KAAA;AACA,YAAAC,EAAA;AACA,OAAAC,KAAA;AACA;EACAC,KAAA;IACA;MACAC,QAAA;MACAC,KAAA;MACAC,MAAA;MACAC,QAAA;MACAC,CAAA;MACAC,QAAA;MACAC,gBAAA;MACAC,iBAAA;MACAC,YAAA;MACAC,KAAA;MACA;MACAC,SAAA;MACAC,KAAA;IACA;EACA;EACAC,QAAA;EACAC,QAAA;IACA,KAAAF,KAAA,OAAAf,KAAA;IACA,KAAAa,KAAA,OAAAlB,KAAA,CAAAuB,KAAA;IACAC,QAAA,CAAAC,IAAA,CAAAC,WAAA,MAAAN,KAAA,CAAAO,UAAA;IACA,KAAAC,KAAA;EACA;EACAC,UAAA;IACA;IACA;IACAC,OAAA,CAAAC,GAAA;EACA;EACAC,OAAA;IACAC,eAAA;MACA,MAAAC,MAAA;MACA,MAAAC,QAAA;MACA,KAAArB,QAAA,OAAAd,KAAA,CAAAoC,cAAA;QACAC,QAAA;UACAC,KAAA;YAAAC,KAAA;UAAA;QACA;QACAC,YAAA,EAAAN,MAAA;QACAO,cAAA,EAAAN;QACA;QACA;MACA;MACA,MAAAO,QAAA,OAAA1C,KAAA,CAAA2C,cAAA;MACA,MAAAC,IAAA,OAAA5C,KAAA,CAAA6C,IAAA,CAAAH,QAAA,OAAA5B,QAAA;MACA,KAAAJ,KAAA,CAAAoC,GAAA,CAAAF,IAAA;IACA;IACA;IACAG,QAAA;MACA,MAAAb,MAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACA,MAAAC,QAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACA,KAAArB,QAAA,OAAAd,KAAA,CAAAoC,cAAA;QACAC,QAAA;UACAC,KAAA;YAAAC,KAAA;UAAA;QACA;QACAC,YAAA,EAAAN,MAAA;QACAO,cAAA,EAAAN;QACA;QACA;MACA;MACA,MAAAO,QAAA,OAAA1C,KAAA,CAAA2C,cAAA;MACA,MAAAC,IAAA,OAAA5C,KAAA,CAAA6C,IAAA,CAAAH,QAAA,OAAA5B,QAAA;MACA,KAAAJ,KAAA,CAAAoC,GAAA,CAAAF,IAAA;IACA;IACA;IACAI,QAAA;MACA,MAAAd,MAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACA,MAAAC,QAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACA,KAAApB,gBAAA,OAAAf,KAAA,CAAAoC,cAAA;QACAC,QAAA;UACAC,KAAA;YAAAC,KAAA;UAAA;QACA;QACAC,YAAA,EAAAN,MAAA;QACAO,cAAA,EAAAN,QAAA;QACAc,WAAA;QACAC,QAAA,EAAAlD,KAAA,CAAAmD;QACA;QACA;MACA;MAEA,MAAAC,gBAAA,OAAApD,KAAA,CAAAqD,cAAA;MACA,MAAAC,CAAA;MACA,MAAAC,SAAA,OAAAC,YAAA,CAAAF,CAAA;MAEA,MAAAG,GAAA,GAAAC,IAAA,CAAAC,EAAA,QAAAD,IAAA,CAAAE,IAAA;MACA,MAAAC,GAAA,OAAAP,CAAA;MACA;MACA;MACA;MAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}